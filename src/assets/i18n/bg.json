{
  "HEADER_TITLE": "Algoplat",
  "WELCOMING_MESSAGE": "Изследвайте света на алгоритмите с интерактивни анимации и изчерпателни обяснения.",
  "START_NOW_MESSAGE": "Започнете своето пътешествие сега!",
  "HOME_LABEL": "Начало",
  "LANGUAGES_LABEL": "Езици",
  "UNI_NAME_LABEL":"ПУ „Паисий Хилендарски“",
  "FACULTY_NAME_LABEL":"Физико-технологичен факултет",
  "AUTHOR_NAME_LABEL":"Дамян Димитров",
  "YEAR_LABEL":"2025",
  "ASCENDING": "Възходящ",
  "DESCENDING": "Низходящ",
  "SORT": "Сортирай",
  "SEARCH": "Търси",
  "PUSH": "Добавяне",
  "POP": "Изваждане",
  "PEEK": "Надникване",
  "SOURCE_CODE": "Изходен код",
  "SEARCHED_ARRAY_LABEL": "Въведете подреден масив от числа: ",
  "SEARCHED_NUMBER_LABEL": "Въведете търсеното число: ",
  "SORTED_ARRAY_LABEL": "Въведете масива от числа за сортиране: ",
  "INPUT_WARNING": "За правилно визуализиране на анимациите използвайте числа между -99 и 99. Максималния брой елементи е 9.",
  "STACK_WARNING": "Зададеният пример е със стек с максимална дължина 4 елемента",
  "QUEUE_WARNING": "Зададеният пример е с опашка с максимална дължина 4 елемента",
  "algorithmTypes": [
    {
      "label": "Сортиращи",
      "source": "sorting",
      "algorithms": [
        {
          "label": "Бързо Сортиране",
          "source": "sorting/quickSort",
          "sourceCode": "int partition(int arr[], int size) { // Подаваме на функцията масива, който ще подрежда и неговия размер\\n\\n    int pivot = arr[ 0 ]; // Избираме първия елемент от масива, за да сравняваме другите с него, наречен пивот\\n\\n    int j = 1; // Задаваме флаг, който да следи по-малките числа от пивота\\n\\n    // Цикъл започващ от индекс 1 за числата от масива след пивота\\n    for (int i = 1; i < size; i++) {\\n    // Проверяваме, дали arr[ i ] е по-малко от пивота\\n        if (arr[ i ] < pivot) {\\n            // В случай, че е по-малко, разменяме местата на числото на позицията i и числото на позицията j\\n            int temp = arr[ i ];\\n            arr[ i ] = arr[ j ] \\n            arr[ j ] = temp;\\n\\n            //Увеличаваме стойността на флага, за да следим колко числа сме преместили на позиция преди пивота\\n            j++;\\n        }\\n    }\\n\\n    // Поставяме пивота на правилната си позиция спрямо по-малките числа, а числото, което се намира на тази позиция поставяме на предишната позиция на пивота\\nint temp = arr[ 0 ];\\n    arr[ 0 ] = arr[ j - 1 ];\\n    arr[ j - 1 ] = temp;\\n\\n    // Като резултат връщаме позицията на пивота\\nreturn j - 1;\\n }\\n\\n void quickSort(int arr[], int left, int right) { // Подаваме на функцията масива, който ще се подрежда, позицията в него от която ще сортира и позицията в него, до която ще сортира\\n\\n    if (left < right) { // Ако началната позиция е по-малка от крайната, продължаваме с изпълнението\\n\\n       // Извикваме функцията, която поставя пивота на правилната му позиция, като подаваме масива, който ще сортираме със зададена начална позиция и размер, като към върнатия резултат добавяме подадената ни по-горе начална точка, за да определим правилната позиция на пивота в основния масив и присвояваме неговата позиция към създадената променлива\\n        int pivotIndex = partition(arr + left, right - left + 1) + left;\\n\\n        // Използвайки рекурсия извикваме същия метод като му подаваме като начална позиция тази, която ни е подадена и крайна позиция позицията на пивота -1, за да подреди числата по-малки от пивота\\n        quickSort(arr, left, pivotIndex - 1);\\n\\n         // Отново използваме рекурсия като този път подаваме начална позиция позицията на пивота + 1, за да можем да сортираме числата след пивота и начална позиция тази, която ни е подадена\\n        quickSort(arr, pivotIndex + 1, right);\\n    }\\n }",
          "information": "&nbsp;&nbsp;&nbsp;&nbsp;Алгоритъмът за бързо сортиране (QuickSort) е ефективен при сортиране на големи набори от данни. Той има сложност О(nlog n). Идеята за бързото сортиране (QuickSort) е да се разменят елементи, които са максимално отдалечени един от друг. Така се намалява броя на сравненията. Това се постига като на всяка стъпка се избира един елемент Х от масива, наречен среден или опорен. След това спрямо него се извършва разделяне на множеството S от всички елементи на масива на две части (всички елементи в S1 са <=X, всички елементи в S2 са >=X). Това разделяне се прави като се използват две индексни променливи i и j към елементите в масива, които се движат от двата края към средата на масива. След това спрямо множествата  S1 и S2 се прилага същата процедура рекурсивно. Това продължава докато размерът на частта, която се сортира стане 1. Получените масиви се сливат (извършва се конкатенация) и се получава сортирания масив. Препоръчително е елементът Х да е такъв, че S1 и S2 да са приблизително еднакви по размери. Практически най-често за опорен елемент се използва  елементът с индекс (L+R)/2 (където L е първият валиден индекс от масива, а R последният).",
          "imgSource": "assets/images/quickSort.jpg"
        },
        {
          "label": "Бъбъл Сортиране",
          "source": "sorting/bubbleSort",
          "sourceCode": "void bubbleSort(int arr[], int size) { // Подаваме на функцията масива за сортиране и неговия размер\\n\\n    for (int i = 0; i < size - 1; i++) {\\n        for (int j = 0; j < size - i - 1; j++) { // Цикълът се повтаря до 'size - i - 1', ако вече имаме числа на правилна позиция, да не минаваме отново през тях\\n\\n            //Проверяваме, ако числото на позиция j е по-голямо от числото на следващата позиция\\n            if (arr[ j ] > arr[j + 1]) {\\n                //Ако то е по-голямо разменяме местата на числата и така изместваме по-голямото надясно\\n                int temp = arr[ j ];\\n                arr[ j ] = arr[ j + 1 ];\\n                arr[ j + 1 ] = temp;\\n            }\\n        }\\n    // След като сме сравнили числата, най-голямото от сравняваните се намира на най-дясна позиция спрямо останалите\\n    }\\n }",
          "information": "&nbsp;&nbsp;&nbsp;&nbsp;Масивът в процеса на изпълнение на алгоритъма е разделен на сортирана лява (от позиция 0 до i-1) и несортирана дясна (от позиция i  до n-1) част. В началото целият масив е в несортираната част. Сортировката може да се реализира чрез последователно сравняване и разместване (по двойки) на елементите, както отляво-надясно, така и отдясно-наляво. В първия случай, при първата стъпка, най-малкият  елемент ще се придвижи най-вдясно, а във втория случай – най-големият – най-вляво. Ще разгледаме програмната реализация на  алгоритъма чрез обхождане  отляво-надясно. При всяко обхождане се сравняват съседните елементи (а[0] и a[1], a[1] и a[2] и т.н.) и ако a[j]<=a[j+1]  не се прави разместване, но в противен случай те си разменят местата. Така след първото обхождане максималният елемент ще отиде на края на масива, т.е последният елемент вече се включва в сортиранта част на масива. Така при всяко обхождане максималният елемент в несортираната част ще отива на мястото си (ще изплува най-отгоре). Масивът ще бъде сортиран след n-1 обхождания на масива. Сложността на алгоритъма е O(n2).",
          "imgSource": "assets/images/bubble-sort.png"
        }
      ]
    },
    {
      "label": "Търсещи",
      "source": "searching",
      "algorithms": [
        {
          "label": "Линейно Търсене",
          "source": "searching/linearSearch",
          "sourceCode": "int linearSearch(int arr[], int size, int target) { // Подаваме на функцията масива, в който ще търсим, неговият размер и търсеното число\\n\\n    for (int i = 0; i < size; i++) { Преминаваме през всяко число от масива\\n\\n        // Сравняваме числото на позицията с търсеното число\\n        if (arr[i] == target) {\\n\\n            // Ако съвпадат, връщаме позицията на която се намира\\n            return i;\\n        }\\n    }\\n    // Ако числото не е намерено, връщаме -1 като индикация\\n    return -1;\\n }",
          "information": "&nbsp;&nbsp;&nbsp;&nbsp;Последователно (или линейно) търсене е алгоритъм за търсене, който проверява елементите на масива един по един, до намиране на съвпадение или до достигане на края на масива. Ако елементът бъде намерен, алгоритъмът връща неговия индекс, в противен случай връща индикация, че елементът не съществува в масива, като най-често се използва числото \"-1\", тъй като не съществува такъв индекс в масивите. Сложността на алгоритъма е  О(n).",
          "imgSource": "assets/images/linear-search.png"
        },
        {
          "label": "Двоично Търсене",
          "source": "searching/binarySearch",
          "sourceCode": "int binarySearch(int arr[], int left, int right, int target) { // Подаваме подреден масив, в който ще търсим, неговото начало, край и търсеното число\\n\\n    while (left <= right) { // Продължаваме търсенето, докато началото на масива, в който търсим е по-малко от края\\n\\n        // Намираме позицията, който се намира по средата на масива, в който търсим\\n        int mid = left + (right - left) / 2;\\n\\n        // Проверяваме, дали числото по средата е търсеното\\n        if (arr[mid] == target) {\\n\\n            // Връщаме позицията на намереното число\\n            return mid;\\n        } else if (arr[mid] < target) { // Проверяваме, дали числото на средната позиция е по-малко от търсеното\\n\\n            // В случай, че е така задаваме средната позиция + 1 като нова начална позиция на масива, в който търсим\\n            left = mid + 1;\\n        } else {\\n\\n            // Ако то е по-голямо, задаваме средната позиция - 1 като крайна позиция на масива, в който търсим \\n            right = mid - 1;\\n        }\\n    }\\n\\n    // Ако числото не е намерено, връщаме -1 като индикация\\n    return -1;\\n }",
          "information": "&nbsp;&nbsp;&nbsp;&nbsp;Двоичното търсене е ефективен алгоритъм за търсене в сортирани масиви. Масивът се разделя на половина. Търсената стойност се сравнява със стойността на средния елемент в масива. Ако средният елемент съвпада с търсената стойност, алгоритъмът завършва. Ако не е, има два варианта: \n &nbsp;&nbsp;&nbsp;&nbsp;1) Ако търсената стойност е по-малка от средния елемент на масива, търсенето продължава в лявата половина на масива, т.е. от първия елемент до елемента, преди средния. \n &nbsp;&nbsp;&nbsp;&nbsp;2) Ако търсената стойност е по-голяма от средния елемент на масива, търсенето продължава в дясната половина на масива, т.е. от елемента след средния, до последния елемент от масива. \n &nbsp;&nbsp;&nbsp;&nbsp;Независимо дали търсенето ще продължи в лявата или дясната половина на масива, отново се намира средния елемент и това продължава докато средният елемент съвпадне с търсения или докато масивът се свие до нула (т.е. елементът липсва). \n &nbsp;&nbsp;&nbsp;&nbsp;При двоичното търсене областта за търсене винаги е половината от предишната област за търсене и това е причината алгоритъмът да е много бърз при големи набори от данни. Сложността на алгоритъма е O(log n).",
          "imgSource": "assets/images/binary-search.png"
        }
      ]
    },
    {
      "label": "Структури от данни",
      "source": "dataStructures",
      "structures": [
        {
          "label": "Стек",
          "source": "stack",
          "sourceCode": "",
          "information": "&nbsp;&nbsp;&nbsp;&nbsp;Стекът е линейна структура, в която записът и четенето се извършват в единия му край, наречен връх. Другият край се нарича дъно. Стекът работи  на принципа LIFO  (Last In, First Out - „последен влязъл, пръв излязъл“),  което означава, че последният добавен елемент е първият, който се премахва.",
          "imgSource": "assets/images/stack.png"
        },
        {
          "label": "Опашка",
          "source": "queue",
          "sourceCode": "",
          "information": "&nbsp;&nbsp;&nbsp;&nbsp;Опашката е линейна структура, при която добавянето на нови елементи става в края, а извличането на елементи става само от началото на опашката. Достъпът до данни се нарича FIFO (First In First Out – „първи влязъл – първи излязъл”), което означава, че първият добавен елемент е първият, който се премахва. \n\n Основни операции с опашка: \n <ul> <li> 1 </li> <li> 2</li> </ul>",
          "imgSource": "assets/images/queue.png"
        }
      ]
    }
  ],
  "advancedAlgorithms": [
    {
      "label": "Сортиращи",
      "source": "sorting",
      "algorithms": [
        {
          "label": "Мърдж Сортиране",
          "source": "sorting/mergeSort",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "Структури от данни",
      "source": "dataStructures",
      "structures": [
        {
          "label": "Масив",
          "source": "array",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "Хеширащи",
      "source": "hashing",
      "algorithms": [
        {
          "label": "MD5",
          "source": "md5",
          "sourceCode": ""
        },
        {
          "label": "SHA-1",
          "source": "sha-1",
          "sourceCode": ""
        },
        {
          "label": "SHA-256",
          "source": "sha-256",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "На случаен принцип",
      "source": "randomized",
      "algorithms": [
        {
          "label": "Монте Карло Интеграция",
          "source": "montecarlointegration",
          "sourceCode": ""
        },
        {
          "label": "Лас Вегас Куиксорт Интеграция",
          "source": "lasvegasintegration",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "Рекурсивни",
      "source": "recursive",
      "algorithms": [
        {
          "label": "Факториален",
          "source": "factorial",
          "sourceCode": ""
        },
        {
          "label": "Последователност на Фибоначи",
          "source": "fibonaccisequence",
          "sourceCode": ""
        }
      ]
    }
  ]
}
