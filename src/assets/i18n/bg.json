{
  "HEADER_TITLE": "Algoplat",
  "WELCOMING_MESSAGE": "Изследвайте света на алгоритмите с интерактивни анимации и изчерпателни обяснения.",
  "START_NOW_MESSAGE": "Започнете своето пътешествие сега!",
  "HOME_LABEL": "Начало",
  "LANGUAGES_LABEL": "Езици",
  "UNI_NAME_LABEL":"ПУ „Паисий Хилендарски“",
  "FACULTY_NAME_LABEL":"Физико-технологичен факултет",
  "AUTHOR_NAME_LABEL":"Дамян Димитров",
  "YEAR_LABEL":"2025",
  "ASCENDING": "Възходящ",
  "DESCENDING": "Низходящ",
  "SORT": "Сортирай",
  "SEARCH": "Търси",
  "PUSH": "Добавяне",
  "POP": "Изваждане",
  "PEEK": "Надникване",
  "SOURCE_CODE": "Изходен код",
  "SEARCHED_ARRAY_LABEL": "Въведете подреден масив от числа: ",
  "SEARCHED_NUMBER_LABEL": "Въведете търсеното число: ",
  "SORTED_ARRAY_LABEL": "Въведете масива от числа за сортиране: ",
  "INPUT_WARNING": "За правилно визуализиране на анимациите използвайте числа между -99 и 99. Максималния брой елементи е 9.",
  "STACK_WARNING": "Зададеният пример е със стек с максимална дължина 4 елемента",
  "QUEUE_WARNING": "Зададеният пример е с опашка с максимална дължина 4 елемента",
  "algorithmTypes": [
    {
      "label": "Сортиращи",
      "source": "sorting",
      "algorithms": [
        {
          "label": "Бързо Сортиране",
          "source": "sorting/quickSort",
          "sourceCode": "int partition(int arr[], int size) { // Подаваме на функцията масива, който ще подрежда и неговия размер\\n\\n    int pivot = arr[ 0 ]; // Избираме първия елемент от масива, за да сравняваме другите с него, наречен пивот\\n\\n    int j = 1; // Задаваме флаг, който да следи по-малките числа от пивота\\n\\n    // Цикъл започващ от индекс 1 за числата от масива след пивота\\n    for (int i = 1; i < size; i++) {\\n    // Проверяваме, дали arr[ i ] е по-малко от пивота\\n        if (arr[ i ] < pivot) {\\n            // В случай, че е по-малко, разменяме местата на числото на позицията i и числото на позицията j\\n            int temp = arr[ i ];\\n            arr[ i ] = arr[ j ] \\n            arr[ j ] = temp;\\n\\n            //Увеличаваме стойността на флага, за да следим колко числа сме преместили на позиция преди пивота\\n            j++;\\n        }\\n    }\\n\\n    // Поставяме пивота на правилната си позиция спрямо по-малките числа, а числото, което се намира на тази позиция поставяме на предишната позиция на пивота\\nint temp = arr[ 0 ];\\n    arr[ 0 ] = arr[ j - 1 ];\\n    arr[ j - 1 ] = temp;\\n\\n    // Като резултат връщаме позицията на пивота\\nreturn j - 1;\\n }\\n\\n void quickSort(int arr[], int left, int right) { // Подаваме на функцията масива, който ще се подрежда, позицията в него от която ще сортира и позицията в него, до която ще сортира\\n\\n    if (left < right) { // Ако началната позиция е по-малка от крайната, продължаваме с изпълнението\\n\\n       // Извикваме функцията, която поставя пивота на правилната му позиция, като подаваме масива, който ще сортираме със зададена начална позиция и размер, като към върнатия резултат добавяме подадената ни по-горе начална точка, за да определим правилната позиция на пивота в основния масив и присвояваме неговата позиция към създадената променлива\\n        int pivotIndex = partition(arr + left, right - left + 1) + left;\\n\\n        // Използвайки рекурсия извикваме същия метод като му подаваме като начална позиция тази, която ни е подадена и крайна позиция позицията на пивота -1, за да подреди числата по-малки от пивота\\n        quickSort(arr, left, pivotIndex - 1);\\n\\n         // Отново използваме рекурсия като този път подаваме начална позиция позицията на пивота + 1, за да можем да сортираме числата след пивота и начална позиция тази, която ни е подадена\\n        quickSort(arr, pivotIndex + 1, right);\\n    }\\n }",
          "information": "Quick Sort (Бързо сортиране) е широко известен и ефективен алгоритъм за сортиране на големи набори от данни. Той има сложност O(n log n), което го прави добър избор за повечето ситуации на сортиране, но в най-лошия случай може да има сложност O(n2). Алгоритъмът работи като избира главен елемент, наречен пивот, като след това сравнява елементите от масива с главния елемент, премествайки по-малките от ляво на пивота, а по-големите отдясно. След това същата стъпка се повтаря рекурсивно използвайки масив, който съдържа по-малките елементи и съответно масив, който съдържа по-големите. Това се повтаря, докато не се стигне до масив от един елемент, като при завършване на рекурсията, получените масиви се сливат (конкатенират), запазвайки пивотите между тях, за да се получи подреден масив.",
          "imgSource": "assets/images/quickSort.jpg"
        },
        {
          "label": "Бъбъл Сортиране",
          "source": "sorting/bubbleSort",
          "sourceCode": "void bubbleSort(int arr[], int size) { // Подаваме на функцията масива за сортиране и неговия размер\\n\\n    for (int i = 0; i < size - 1; i++) {\\n        for (int j = 0; j < size - i - 1; j++) { // Цикълът се повтаря до 'size - i - 1', ако вече имаме числа на правилна позиция, да не минаваме отново през тях\\n\\n            //Проверяваме, ако числото на позиция j е по-голямо от числото на следващата позиция\\n            if (arr[ j ] > arr[j + 1]) {\\n                //Ако то е по-голямо разменяме местата на числата и така изместваме по-голямото надясно\\n                int temp = arr[ j ];\\n                arr[ j ] = arr[ j + 1 ];\\n                arr[ j + 1 ] = temp;\\n            }\\n        }\\n    // След като сме сравнили числата, най-голямото от сравняваните се намира на най-дясна позиция спрямо останалите\\n    }\\n }",
          "information": "Bubble Sort (Сортиране чрез мехурчета) е един от най-простите алгоритми за сортиране. Той работи, като многократно обхожда списъка, сравнява съседни елементи и ги разменя, ако са в грешен ред. Този процес се повтаря, докато списъкът не бъде напълно сортиран.",
          "imgSource": "assets/images/bubble-sort.png"
        }
      ]
    },
    {
      "label": "Търсещи",
      "source": "searching",
      "algorithms": [
        {
          "label": "Линейно Търсене",
          "source": "searching/linearSearch",
          "sourceCode": "int linearSearch(int arr[], int size, int target) { // Подаваме на функцията масива, в който ще търсим, неговият размер и търсеното число\\n\\n    for (int i = 0; i < size; i++) { Преминаваме през всяко число от масива\\n\\n        // Сравняваме числото на позицията с търсеното число\\n        if (arr[i] == target) {\\n\\n            // Ако съвпадат, връщаме позицията на която се намира\\n            return i;\\n        }\\n    }\\n    // Ако числото не е намерено, връщаме -1 като индикация\\n    return -1;\\n }",
          "information": "Linear Search (Линейно търсене) е прост алгоритъм за търсене, който преминава през елементите на масива един по един, докато не намери търсения елемент. Ако елементът бъде намерен, алгоритъмът връща неговия индекс, в противен случай връща индикация, че елементът не съществува в масива, като най-често се използва числото \"-1\", тъй не съществува такъв индекс в масивите.",
          "imgSource": "assets/images/linear-search.png"
        },
        {
          "label": "Бинарно Търсене",
          "source": "searching/binarySearch",
          "sourceCode": "int binarySearch(int arr[], int left, int right, int target) { // Подаваме подреден масив, в който ще търсим, неговото начало, край и търсеното число\\n\\n    while (left <= right) { // Продължаваме търсенето, докато началото на масива, в който търсим е по-малко от края\\n\\n        // Намираме позицията, който се намира по средата на масива, в който търсим\\n        int mid = left + (right - left) / 2;\\n\\n        // Проверяваме, дали числото по средата е търсеното\\n        if (arr[mid] == target) {\\n\\n            // Връщаме позицията на намереното число\\n            return mid;\\n        } else if (arr[mid] < target) { // Проверяваме, дали числото на средната позиция е по-малко от търсеното\\n\\n            // В случай, че е така задаваме средната позиция + 1 като нова начална позиция на масива, в който търсим\\n            left = mid + 1;\\n        } else {\\n\\n            // Ако то е по-голямо, задаваме средната позиция - 1 като крайна позиция на масива, в който търсим \\n            right = mid - 1;\\n        }\\n    }\\n\\n    // Ако числото не е намерено, връщаме -1 като индикация\\n    return -1;\\n }",
          "information": "Binary Search (Бинарно търсене) е ефективен алгоритъм за търсене в сортирани масиви. Той работи, като повтаря разделянето на масива на две половини, сравнява търсеното число с това, което се намира между двете половини и в зависимост, дали е по-малко или по-голямо, съответно продължава търсенето в лявата или дясната половина. Това намалява броя на елементите, които трябва да се проверят с всяка стъпка. Бинарното търсене е много подходящ алгоритъм за търсене в големи колекции от данни.",
          "imgSource": "assets/images/binary-search.png"
        }
      ]
    },
    {
      "label": "Структури от данни",
      "source": "dataStructures",
      "structures": [
        {
          "label": "Стек",
          "source": "stack",
          "sourceCode": "",
          "information": "Stack (Стек) е абстракция за структури от данни, която работи по принципа \"последен влязъл, първи излязъл\" (LIFO - Last In, First Out). Това означава, че последният елемент, който е добавен в стека, ще бъде първият, който ще бъде премахнат. Добър пример за използването на такъв тип структура от данни е функцията на браузърите да връщат към предходна страница - последната посетена страница ще бъде първата, към която ще се върне потребителя.",
          "imgSource": "assets/images/stack.png"
        },
        {
          "label": "Опашка",
          "source": "queue",
          "sourceCode": "",
          "information": "Queue (Опашка) е структура от данни, която работи по принципа \"първи влязъл, първи излязъл\" (FIFO - First In, First Out). Това означава, че първият елемент, който е добавен в опашката, ще бъде и първият, който ще бъде премахнат. Добър пример за структурата от данни в реалния свят е както името подсказва - опашка. Първият наредил се на опашката бива първият обслужен. Чатовете по социалните мрежи също могат да са добър пример - дори при бавна интернет връзка или липсата на такава, редът на изпратениет съобщения ще бъде същият, когато те бъдат получени - първото изпратено ще бъде първото получено. ",
          "imgSource": "assets/images/queue.png"
        }
      ]
    }
  ],
  "advancedAlgorithms": [
    {
      "label": "Сортиращи",
      "source": "sorting",
      "algorithms": [
        {
          "label": "Мърдж Сортиране",
          "source": "sorting/mergeSort",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "Структури от данни",
      "source": "dataStructures",
      "structures": [
        {
          "label": "Масив",
          "source": "array",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "Хеширащи",
      "source": "hashing",
      "algorithms": [
        {
          "label": "MD5",
          "source": "md5",
          "sourceCode": ""
        },
        {
          "label": "SHA-1",
          "source": "sha-1",
          "sourceCode": ""
        },
        {
          "label": "SHA-256",
          "source": "sha-256",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "На случаен принцип",
      "source": "randomized",
      "algorithms": [
        {
          "label": "Монте Карло Интеграция",
          "source": "montecarlointegration",
          "sourceCode": ""
        },
        {
          "label": "Лас Вегас Куиксорт Интеграция",
          "source": "lasvegasintegration",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "Рекурсивни",
      "source": "recursive",
      "algorithms": [
        {
          "label": "Факториален",
          "source": "factorial",
          "sourceCode": ""
        },
        {
          "label": "Последователност на Фибоначи",
          "source": "fibonaccisequence",
          "sourceCode": ""
        }
      ]
    }
  ]
}
