{
  "HEADER_TITLE": "Algoplat",
  "WELCOMING_MESSAGE": "Изследвайте света на алгоритмите с интерактивни анимации и изчерпателни обяснения.",
  "START_NOW_MESSAGE": "Започнете своето пътешествие сега!",
  "HOME_LABEL": "Начало",
  "LANGUAGES_LABEL": "Езици",
  "UNI_NAME_LABEL":"ПУ „Паисий Хилендарски“",
  "FACULTY_NAME_LABEL":"Физико-технологичен факултет",
  "AUTHOR_NAME_LABEL":"Дамян Димитров",
  "YEAR_LABEL":"2025",
  "ASCENDING": "Възходящ",
  "DESCENDING": "Низходящ",
  "SORT": "Сортирай",
  "SEARCH": "Търси",
  "PUSH": "Добавяне",
  "POP": "Изваждане",
  "PEEK": "Надникване",
  "SOURCE_CODE": "Изходен код",
  "algorithmTypes": [
    {
      "label": "Сортиращи",
      "source": "sorting",
      "algorithms": [
        {
          "label": "Бързо Сортиране",
          "source": "sorting/quickSort",
          "sourceCode": "int partition(int arr[], int low, int high) {\\n    int pivot = arr[high];\\n    int i = low - 1;\\n\\n    for (int j = low; j < high; j++) {\\n        if (arr[j] < pivot) {\\n            i++;\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n\\n    swap(arr[i + 1], arr[high]);\\n    return i + 1;\\n }\\n\\n void quickSort(int arr[], int low, int high) {\\n    if (low < high) {\\n        int pivotIndex = partition(arr, low, high);\\n\\n        quickSort(arr, low, pivotIndex - 1);\\n        quickSort(arr, pivotIndex + 1, high);\\n    }\\n }",
          "information": "Quick Sort (Бързо сортиране) е широко известен и изключително ефективен алгоритъм за сортиране на големи набори от данни. Той има сложност O(n log n), което го прави често предпочитан избор за повечето ситуации на сортиране, но в най-лошия случай може да има сложност O(n^2), ако не е правилно имплементиран. Алгоритъмът рекурсивно разделя масива на по-малки подмассиви, базирани на опорен елемент (pivot).",
          "imgSource": "assets/images/quickSort.jpg"
        },
        {
          "label": "Бъбъл Сортиране",
          "source": "sorting/bubbleSort",
          "sourceCode": "void bubbleSort(int arr[], int n) {\\n    for (int i = 0; i < n - 1; i++) {\\n        for (int j = 0; j < n - i - 1; j++) {\\n            if (arr[j] > arr[j + 1]) {\\n                int temp = arr[j];\\n                arr[j] = arr[j + 1];\\n                arr[j + 1] = temp;\\n            }\\n        }\\n    }\\n }",
          "information": "Bubble Sort (Сортиране чрез мехурчета) е един от най-простите алгоритми за сортиране. Той работи, като многократно обхожда списъка, сравнява съседни елементи и ги разменя, ако са в грешен ред. Този процес се повтаря, докато списъкът не бъде напълно сортиран.",
          "imgSource": "assets/images/bubble-sort.jpg"
        }
      ]
    },
    {
      "label": "Търсещи",
      "source": "searching",
      "algorithms": [
        {
          "label": "Линейно Търсене",
          "source": "searching/linearSearch",
          "sourceCode": "int linearSearch(int arr[], int n, int target) {\\n    for (int i = 0; i < n; i++) {\\n        if (arr[i] == target) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n }",
          "information": "Linear Search (Линейно търсене) е прост алгоритъм за търсене, който преминава през елементите на масива един по един, докато не намери търсения елемент. Ако елементът бъде намерен, алгоритъмът го връща, в противен случай връща индикация, че елементът не съществува в масива.",
          "imgSource": "assets/images/linear-search.png"
        },
        {
          "label": "Бинарно Търсене",
          "source": "searching/binarySearch",
          "sourceCode": "int binarySearch(int arr[], int left, int right, int target) {\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (arr[mid] == target) {\\n            return mid;\\n        } else if (arr[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n }",
          "information": "Binary Search (Бинарно търсене) е ефективен алгоритъм за търсене в сортирани масиви. Той работи, като повтаря разделянето на масива на две половини и избира в коя половина да продължи търсенето в зависимост от стойността на търсения елемент. Това намалява броя на елементите, които трябва да се проверят с всяка стъпка.",
          "imgSource": "assets/images/binary-search.png"
        }
      ]
    },
    {
      "label": "Структури от данни",
      "source": "dataStructures",
      "structures": [
        {
          "label": "Стек",
          "source": "stack",
          "sourceCode": "",
          "information": "Stack (Стек) е абстракция за структури от данни, която работи по принципа \"последен влязъл, първи излязъл\" (LIFO - Last In, First Out). Това означава, че последният елемент, който е добавен в стека, ще бъде първият, който ще бъде премахнат.",
          "imgSource": "assets/images/stack.png"
        },
        {
          "label": "Опашка",
          "source": "queue",
          "sourceCode": "",
          "information": "Queue (Опашка) е структура от данни, която работи по принципа \"първи влязъл, първи излязъл\" (FIFO - First In, First Out). Това означава, че първият елемент, който е добавен в опашката, ще бъде и първият, който ще бъде премахнат.",
          "imgSource": "assets/images/queue.png"
        }
      ]
    }
  ],
  "advancedAlgorithms": [
    {
      "label": "Сортиращи",
      "source": "sorting",
      "algorithms": [
        {
          "label": "Мърдж Сортиране",
          "source": "sorting/mergeSort",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "Структури от данни",
      "source": "dataStructures",
      "structures": [
        {
          "label": "Масив",
          "source": "array",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "Хеширащи",
      "source": "hashing",
      "algorithms": [
        {
          "label": "MD5",
          "source": "md5",
          "sourceCode": ""
        },
        {
          "label": "SHA-1",
          "source": "sha-1",
          "sourceCode": ""
        },
        {
          "label": "SHA-256",
          "source": "sha-256",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "На случаен принцип",
      "source": "randomized",
      "algorithms": [
        {
          "label": "Монте Карло Интеграция",
          "source": "montecarlointegration",
          "sourceCode": ""
        },
        {
          "label": "Лас Вегас Куиксорт Интеграция",
          "source": "lasvegasintegration",
          "sourceCode": ""
        }
      ]
    },
    {
      "label": "Рекурсивни",
      "source": "recursive",
      "algorithms": [
        {
          "label": "Факториален",
          "source": "factorial",
          "sourceCode": ""
        },
        {
          "label": "Последователност на Фибоначи",
          "source": "fibonaccisequence",
          "sourceCode": ""
        }
      ]
    }
  ]
}
